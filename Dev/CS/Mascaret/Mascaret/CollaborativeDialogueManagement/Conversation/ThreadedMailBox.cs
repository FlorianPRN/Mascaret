//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//     Version du runtime :4.0.30319.42000
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections;
using System.Threading;

namespace DM
{
	public class ThreadedMailBoxT<T>
	{
		//Define the queue to safe thread access.
		private Queue<T> _inputQueue;
		private EventWaitHandle _newItemEvent;
		private Int32 _newItemCount;
		private EventWaitHandle _exitThreadEvent;
		private WaitHandle[] _eventArray;
		
		public ThreadedMailBoxT()
		{
			_inputQueue = new Queue<T>();
			_newItemEvent = new ManualResetEvent(false);
			_newItemCount = 0;
			_exitThreadEvent = new ManualResetEvent(false);
			_eventArray = new WaitHandle[2];
			_eventArray[0] = _exitThreadEvent;
			_eventArray[1] = _newItemEvent;
		}
		
		//Add a message to the queue and obtain the monitor lock for the queue object.
		public void PushMsg( T qValue)
		{
			//Protect access to the queue.
			lock (((ICollection)_inputQueue).SyncRoot)
			{
				//Add message
				_inputQueue.Enqueue(qValue);
				//signal the new message in the queue and increse the newItemCount
				_newItemCount++;
				_newItemEvent.Set();
				
			}
		}
		
		
		//Wait for a signal and get a message from the queue if there is one
		//by obtaining the monitor lock for the queue object.
		// return false if a signal END is caugh and so no message got , true otherwise
		public T GetMsg( )
		{
			T qValue;
			qValue = default(T);
			
			//Wait for a new messsage or end signal.
			switch (WaitHandle.WaitAny(_eventArray))
			{
			case 0:
				return qValue;
			case 1:
				//Protect access to the queue.
				lock (((ICollection)_inputQueue).SyncRoot)
				{
					//get message
					try
					{
						qValue = _inputQueue.Dequeue();
						_newItemCount--;
					}
					catch (System.InvalidOperationException e)
					{
						Console.WriteLine("{0} Exception caught, the queue is empty.", e);
					}
					if (_newItemCount == 0)
					{
						_newItemEvent.Reset();
					}
					
				}
				return qValue;
				
			default:
				return qValue;
			}
		}
		
		
		public void SignalEnd()
		{
			_exitThreadEvent.Set();
		}
		
		//return true if _exitThreadEvent is set, false otherwise.
		public Boolean IsEnd()
		{
			return (_exitThreadEvent.WaitOne(0, false));
		}
		
		//return true is there is no message in the box, false otherwise.
		public Boolean Empty()
		{
			return (!_newItemEvent.WaitOne(0, false));
		}
		
	}
	
	public class ThreadedMailBox : ThreadedMailBoxT<UtteranceMessage>
	{ 
		
	}
}
